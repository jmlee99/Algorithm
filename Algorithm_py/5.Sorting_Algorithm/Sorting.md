# Sorting Algorithm

***정렬***이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.

정렬 알고리즘으로 데이터를 정렬하면 다음 장에서 배울 이진 탐색이 가능해진다.

정렬 알고리즘은 이진탐색의 전처리 과정이기도 하니 제대로 알고 넘어가자.

정렬 알고리즘은 굉장히 다양한데 이 중에서 많이 사용하는 것은 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬이다.

오름차순을 기준으로 설명을 진행하겠다.

***선택 정렬***

데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음은 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하면 어떨까?

이 방법은 가장 원시적인 방법으로 매번 '가장 작은 것을 선택'한다는 의미에서 선택 정렬알고리즘이라고 한다.

        # 선택 정렬 소스 코드_1
        array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
        
        for i in range(len(array)):
            min_index = i
            for j in range(i + 1, len(array)):
                if array[min_index] > array[j]:
                    min_index = j
            array[i], array[min_index] = array[min_index], array[i] # 스와프
        
        print(array)
        
        # 선택 정렬 소스 코드_2
        # 0 인덱스와 1 인덱스의 원소 교체하기
        array = [3, 5]
        array[0], array[1] = array[1], array[0]
        
        print(array)


***삽입 정렬***

**선택 정렬은 알고리즘 문제 풀이에 사용하기에는 느린 편이다.** 그렇다면 다른 접근 방법에 대해서 생각해보자

'데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?'

삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬 되어 있을 때' 효율적이다.

삽입 정렬은 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.

삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.

***퀵 정렬***

퀵 정렬은 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.

'기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?'

퀵 정렬에서는 피벗이 사용된다. 큰 숫자와 작은 숫자를 교환 큰 숫자와 작으 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 ***피벗***이라고 표현한다.

퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야 한다.

피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분하는데, 가장 대표적인 분할 방식인 ***호어 분할 방식***을 기준으로 퀵 정렬을 설명한다.

***호어 분할 방식***에서는 다음과 같은 규칙에 따라서 피벗을 설정한다.
- 리스트에서 첫 번째 데이터를 피벗으로 정한다.

이와 같이 피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다.

그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.

이러한 과정을 반복하면 ***피벗***에 대하여 정렬이 수행된다. 자세한 과정은 그림으로 살펴보며 이해해보자.

다음과 같이 초기 데이터가 구성되어 있다고 가정해보자 

5, 7, 9, 0, 3, 1, 6, 2, 4, 8

- 파트 1
1. 리스트의 첫 번째 데이터를 피벗으로 설정하므로 피벗은 '5'이다. 이후에 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경한다.

2. 그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 각각 찾는다. 찾은 뒤에는 두 값의 위치를 서로 변경하는데, 현재 '9'와 '2'가 선택되었으로므 이 두 데이터의 위치를 서로 변경한다.

3. 그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 찾는다. 단, 현재 왼쪽에서부터 찾는 값과 오른쪽에서부터 찾는 값의 위치가 서로 엇갈린 것을 알 수 있다. 이렇게 두 값이 엇갈린 경우에는 '작은 데이터'와 '피벗'의 위치를 서로 변경한다. 즉, 작은 데이터인 '1'과 피벗인 '5'의 위치를 서로 변경하여 분할을 수행한다.

4. **분할 완료** 이와 같이 피벗이 이동한 상태에서 왼쪽 리스트와 오른쪽 리스트를 살펴보자, 이제 '5'의 왼쪽에 있는 데이터는 모두 '5'보다 작고, 오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있다. 이렇게 피벗의 왼쪽에는 피벗보다 작은 데이터가 위치하고, 피벗의 오른쪽에는 피벗보다 큰 데이터가 위치하도록 하는 작을 **분할** 혹은 **파티션**이라고 한다.

5. 이러한 상태에서 왼쪽과 오른쪽의 각각의 피벗을 설정하여 동일한 방식으로 정렬을 수행하면 전체 리스트에 대하여 모두 정렬이 이루어질 것이다.


    # 직관적인 퀵 정렬 코드
    array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
    
    def quick_sort(array, start, end):
        if start >= end: # 원소가 1개인 경우 종료
            return
        pivot = start # 피벗은 첫번째 원소
        left = start + 1
        right = end
        while left <= right:
            #피벗보다 큰 데이터를 찾을 때까지 반복

            while (left <= end) and (array[left] <= array[pivot]):
                left += 1

            #피벗보다 작은 데이터를 찾을 때까지 반복
            while (right > start) and (array[right] >= array[pivot]):
                right -= 1

            if left > right: # 엇갈렸다면 작은 데이터와 피벗을 교체
                array[right], array[pivot] = array[pivot], array[right]
            else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
                array[left], array[right] = array[right], array[left]

        #분할 이루 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
        quick_sort(array, start, right - 1)
        quick_sort(array, right + 1, end)
    
    quick_sort(array, 0, len(array) - 1)
    print(array)


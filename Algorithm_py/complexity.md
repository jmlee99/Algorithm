# 알고리즘

#### 복잡도
> 복잡도는 알고리즘의 성능을 나타내는 척도이다.
  1. 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수 
  2. 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양
  3. 메모이제이션 기법실제로 메모리를 더 많이 사용해서 시간을 비약적으로 줄이는 방법

#### 시간 복잡도
> 시간복잡도를 표현할 때는 빅오 표기법을 사용한다.
>> 빅오 표기법 : 가장 빠르게 증가하는 항만을 고려하는 표기법이다. 
>>
>> ***시간복잡도 표 ( 빅오 표기법 | 명칭 ), 위쪽에 있을수록 더 빠르다.***
  1.    O($1$) : 상수시간
 
  2.    O($logN$) : 로그시간
 
  3.    O($N$) : 선형시간
 
  4.    O($NlogN$) : 로그 선형 시간
 
  5.    O($N^2$) : 이차 시간
 
  6.    O($N^3$) : 삼차 시간
 
  7.    O($2^n$) : 지수 시간

  * 만약 $N^3 + N^2 + 1,000,000$에서 N = 10 이라면 상수의 영향력이 더 크다. 항상 빅오 표기법이 맞는 건 아니다.
    * 또한, 시간복잡도가 동일하더라도 실제 연산 횟수에서는 이가 날 수 있다.
    *     N = 1,000일때, 연산횟수는 다음과 같다.
    * 1.    O($N$) : 선형시간 == 1,000
    * 2.    O($NlogN$) : 로그 선형 시간 == 10,000
    * 3.    O($N^2$) : 이차 시간 == 1,000,000
    * 4.    O($N^3$) : 삼차 시간 == 1,000,000,000
    *     빅오 표기법으로 표시한 시간 복잡도가 같더라도 알고리즘의 내부 로직 및 차수가 낮은 항의 영향에 따라 실제 수행된느 연산 횟수는 다를 수 있다.
     
   * ***문제의 조건을 확인하자!***
   * EX) 다음은 모두 시간 제한이 1초인 문제에 대한 예시이다.
      1. N의 범위가 500인 경우 : 시간 복잡도가 O($N^3$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      2. N의 범위가 2,000인 경우 : 시간 복잡도가 O($N^2$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      3. N의 범위가 100,000인 경우 : 시간 복잡도가 O($NlogN$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      4. N의 범위가 10,000,000인 경우 : 시간 복잡도가 O($N$)인 알고리즘을 설계하면 문제를 풀 수 있다.

#### 공간 복잡도
> 앞서 시간 복잡도에서 1초라는 절대적인 제한을 둔 것 처럼, 공간 복잡도에도 MB 단위라는 절대적인 제한이 있다.
1. 대부분의 문제는 리스트(배열)로 풀어야 한다.
2. 다수의 데이터에 대한 효율적인 처리를 요구한다.
  * int를 기준으로 리스트 크기에 따흔 메모리 사용량을 확인 필요
  * int a[1000] : 4KB
  * int a[1000000] : 4MB
  * int a[2000][2000] : 16MB
3. 보통 메모리 사용량을 128 ~ 512MB 정도로 제한한다. => 데이터의 개수가 1,000만 단위가 넘어가지 않도록 설계 해야한다.
4. 파이썬에는 int라는 자료형이 없지만, 대략 100만 개 이상의 데이터가 들어갈 수 있는 크기의 리스트를 선언하는 경우는 적다.
5. ***만약 리스트의 크기가 1,000만 단위 이상이라면, 알고리즘을 잘못 설계 한 것이다.***

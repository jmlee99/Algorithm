# 알고리즘

#### 복잡도
> 복잡도는 알고리즘의 성능을 나타내는 척도이다.
  1. 시간 복잡도 : 알고리즘을 위해 필요한 연산의 횟수 
  2. 공간 복잡도 : 알고리즘을 위해 필요한 메모리의 양
  3. 메모이제이션 기법실제로 메모리를 더 많이 사용해서 시간을 비약적으로 줄이는 방법

#### 시간 복잡도
> 시간복잡도를 표현할 때는 빅오 표기법을 사용한다.
>> 빅오 표기법 : 가장 빠르게 증가하는 항만을 고려하는 표기법이다. 
>>
>> ***시간복잡도 표 ( 빅오 표기법 | 명칭 ), 위쪽에 있을수록 더 빠르다.***
  1.    O($1$) : 상수시간
 
  2.    O($logN$) : 로그시간
 
  3.    O($N$) : 선형시간
 
  4.    O($NlogN$) : 로그 선형 시간
 
  5.    O($N^2$) : 이차 시간
 
  6.    O($N^3$) : 삼차 시간
 
  7.    O($2^n$) : 지수 시간

  * 만약 $N^3 + N^2 + 1,000,000$에서 N = 10 이라면 상수의 영향력이 더 크다. 항상 빅오 표기법이 맞는 건 아니다.
    * 또한, 시간복잡도가 동일하더라도 실제 연산 횟수에서는 이가 날 수 있다.
    *     N = 1,000일때, 연산횟수는 다음과 같다.
    * 1.    O($N$) : 선형시간 == 1,000
    * 2.    O($NlogN$) : 로그 선형 시간 == 10,000
    * 3.    O($N^2$) : 이차 시간 == 1,000,000
    * 4.    O($N^3$) : 삼차 시간 == 1,000,000,000
    *     빅오 표기법으로 표시한 시간 복잡도가 같더라도 알고리즘의 내부 로직 및 차수가 낮은 항의 영향에 따라 실제 수행된느 연산 횟수는 다를 수 있다.
     
   * ***문제의 조건을 확인하자!***
   * EX) 다음은 모두 시간 제한이 1초인 문제에 대한 예시이다.
      1. N의 범위가 500인 경우 : 시간 복잡도가 O($N^3$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      2. N의 범위가 2,000인 경우 : 시간 복잡도가 O($N^2$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      3. N의 범위가 100,000인 경우 : 시간 복잡도가 O($NlogN$)인 알고리즘을 설계하면 문제를 풀 수 있다.
      4. N의 범위가 10,000,000인 경우 : 시간 복잡도가 O($N$)인 알고리즘을 설계하면 문제를 풀 수 있다.

#### 공간 복잡도
> 앞서 시간 복잡도에서 1초라는 절대적인 제한을 둔 것 처럼, 공간 복잡도에도 MB 단위라는 절대적인 제한이 있다.
1. 대부분의 문제는 리스트(배열)로 풀어야 한다.
2. 다수의 데이터에 대한 효율적인 처리를 요구한다.
  * int를 기준으로 리스트 크기에 따흔 메모리 사용량을 확인 필요
  * int a[1000] : 4KB
  * int a[1000000] : 4MB
  * int a[2000][2000] : 16MB
3. 보통 메모리 사용량을 128 ~ 512MB 정도로 제한한다. => 데이터의 개수가 1,000만 단위가 넘어가지 않도록 설계 해야한다.
4. 파이썬에는 int라는 자료형이 없지만, 대략 100만 개 이상의 데이터가 들어갈 수 있는 크기의 리스트를 선언하는 경우는 적다.
5. ***만약 리스트의 크기가 1,000만 단위 이상이라면, 알고리즘을 잘못 설계 한 것이다.***

#### 시간과 메모리 측정
> 파이썬에서는 프로그램 수행 시간과 메모리 사용량을 측정할 수 있다.
> 1. 어떤 알고리즘을 설계한 뒤에 시간 복잡도를 경험적으로 증명하고 싶을 때는 위와 같은 형태의 코드를 자주 이용한다.
> 
          import time
          start_time = time.time() # 측정시작
          # 프로그램 소스코드
          end_time = time.time() # 측정종료
          print("time :", end_time - start_time) # 수행 시간 측정
                
> EX) '선택 정렬'과 '파이썬의 기본 정렬 라이브러리'의 속도를 비교할 때는 다음 쪽과 같이 소스 코드 작성 가능
> 
> ***선택 정렬의 최악의 경우는 O($N^2$)이며, 기본 정렬 라이브러리는 최악의 경우 O($NolgN$)을 보장하여 상대적으로 빠르다.***

>               from random import randint
                import time
                
                # 배열에 10,000개의 정수를 삽입
                array=[]
                for _ in range(10000):
                    array.append(randint(1, 100)) # 1부터 100 사이의 랜덤한 정수
                
                # 선택 정렬 프로그램 성능 측정
                start_time = time.time()
                
                #선택 정렬 프로그램 성능 소스코드
                for i in range(lne(array)):
                    min_index = i # 가장 작은 원소의 인뎃스
                    for j in range(i + 1, len(array)):
                        if array[min_index] > array[j]:
                            min_index = j
                    array[i], array[min_index] = array[min_index], array[i] # 스와프
                    
                end_time = time.time() # 측정종료
                print("선택 정렬 성능 측정:", end_time - start_time) # 수행 시간 출력
                
                # 배열을 다시 무작위 데이터로 초기화
                array = []
                for _ in range(10000):
                    array.append(randint(1, 100)) # 1부터 100 사이의 랜덤한 정수
                    
                # 기본 정렬 라이브러리 성능 측정
                start_time = time.time()
                
                # 기본 정렬 라이브러리 사용
                array.sort()
                
                end_time = time.time() # 측정 종료
                print("기본 정렬 라이브러리 성능 측정:", end_time - start_time) # 수행 시간 출력
                
결과는 
* 선택 정렬 성능 측정: 8.847666501998901
* 기본 정렬 라이브러리 성능 측정: 0.001847982406616211
이상으로 복잡도의 개념에 대해서 알아보고 실제로 수행 시간을 측정하여 시간 복잡도를 검증하는 방법이다.
